Perfect. Below is a **clean, authoritative Layer 0 plan** that replaces the prior drafts.

This version:

* Uses **global SQLite index**
* Uses **run lock for manifest only**
* Defines artifact ID format
* Defines durability ordering
* Clarifies hash semantics
* Clarifies artifact_name semantics
* Locks down invariants
* Removes ambiguity between previous versions

You can drop this directly into your repo as:

```
docs/kernel/layer_0_run_store.md
```

---

# Layer 0 — Run Store (Filesystem-First, Global Index)

Layer 0 defines the **durable foundation** of the kernel:

> Run Directory + Run Manifest + Artifact Store API + Global Artifact Index

It is designed to be:

* Boring
* Deterministic
* Crash-safe
* Concurrency-correct
* Universally reusable across domains

Layer 0 contains **no domain logic**.

---

# 0. Design Principles

1. Artifacts are immutable by construction.
2. The filesystem stores payloads.
3. SQLite stores metadata.
4. Manifest writes are single-writer per run.
5. SQLite handles concurrency for index writes.
6. All artifact paths are confined to the run root.
7. No ad-hoc writes inside the run directory.

---

# 1. Run Identity & Directory Contract

## 1.1 Run ID

* `run_id = uuid4()`
* Format: standard UUID string
* Generated by a single dedicated function

**Tracking:**

- [x] **RunId generator** — single function, returns uuid4 string

---

## 1.2 Run Directory Layout

```
.iris/
  index.sqlite                # Global artifact index
  runs/
    <run_id>/
      run_manifest.json
      artifacts/
        <artifact_id>/
          payload.json | payload.txt | <file>
      logs/
      tmp/
      .lock
```

### Invariants

* Kernel owns everything under `.iris/runs/<run_id>/`
* No user code writes files directly under this tree
* `tmp/` is non-durable and may be wiped anytime

**Tracking:**

- [x] **Run directory creator** — create `.iris/runs/<run_id>/` and subdirs (`artifacts/`, `logs/`, `tmp/`, `.lock` parent)
- [x] **Layout documented** — layout and invariants in code/docs
- [x] **Invariants enforced** — kernel owns tree; no direct user writes; tmp/ clearable

---

# 2. Concurrency & Locking

Layer 0 must remain correct when:

* Two runs execute concurrently
* Multiple steps write artifacts within one run

## Decision

### Manifest

* Single-writer per run
* Enforced via run-scoped file lock:

  ```
  .iris/runs/<run_id>/.lock
  ```
* Lock held **only during manifest write**
* Lock released immediately after write

### Index

* Global SQLite database at:

  ```
  .iris/index.sqlite
  ```
* SQLite handles writer serialization
* No run lock held during index writes

### Lock Ordering Rule

> Never acquire any other lock while holding the run lock.

This prevents deadlock in higher layers.

**Tracking:**

- [x] **Run lock implementation** — file lock on `.iris/runs/<run_id>/.lock`; acquire only for manifest write, release after
- [x] **Lock ordering documented** — "Never acquire any other lock while holding the run lock" in contract

---

# 3. Run Manifest

## 3.1 Schema

`RunManifest`

* run_id
* created_at
* updated_at
* kernel_version
* status
* work_order_ref: ArtifactRef | None
* workspace_snapshot (optional)

`work_order_ref` is an ArtifactRef, not a string.

---

## 3.2 Manifest Writes

Manifest writes use atomic write procedure:

1. Write to temporary file
2. `fsync()` temporary file
3. Rename to `run_manifest.json`
4. `fsync()` directory (recommended)

Manifest writes are the only operation requiring the run lock.

**Tracking:**

- [x] **RunManifest schema** — Pydantic (or equivalent) with all fields; work_order_ref as ArtifactRef | None
- [x] **RunManifest writer** — create at run start; update updated_at and status on transitions; hold run lock during write
- [x] **Atomic write utility** — write temp → fsync temp → rename → fsync dir; used for manifest only
- [x] **RunManifest reader** — load and parse for resume/audit

---

# 4. Artifact Model

## 4.1 Artifact ID

* `artifact_id = uuid4()`
* Unique per artifact
* Immutable
* Used as directory name under `artifacts/`

---

## 4.2 Artifact Storage Layout

Each artifact stored under:

```
artifacts/<artifact_id>/
  payload.json | payload.txt | <file>
```

Overwrites are impossible by construction.

New version = new artifact_id.

---

## 4.3 ArtifactRef Schema

Fields:

* artifact_id
* run_id
* artifact_type (e.g. `work_order.v1`)
* storage_kind (`json` | `text` | `file`)
* artifact_name (optional, ergonomic only)
* rel_path (relative to run root)
* sha256
* created_at
* producer_id
* producer_kind (`tool` | `llm` | `human` | `system`)
* input_artifact_refs (list of artifact_ids)

### Important

* `artifact_name` is optional
* It is not unique
* It does not imply mutability
* It is for human ergonomics only

**Tracking:**

- [x] **Artifact ID generator** — uuid4, single function; used as directory name
- [x] **Artifact storage layout** — write under `artifacts/<artifact_id>/`; no overwrites
- [x] **ArtifactRef schema** — Pydantic (or equivalent) with all fields including producer_kind, artifact_name

---

# 5. Hashing & Durability Rules

## Hashing

* sha256 is computed on the **stored file**
* Hash computed after copy/move
* Always computed (no shortcuts)

## Durability Ordering

Correct write order for `put_*`:

1. Write artifact payload to disk
2. `fsync()` payload file
3. Insert metadata row into SQLite (transaction)
4. Commit transaction

Never insert index row before payload write completes.

**Tracking:**

- [x] **Hashing** — sha256 on stored file after write; always computed in put_json / put_text / put_file
- [x] **Durability ordering** — payload write + fsync before index insert in all put_* implementations

---

# 6. Global Artifact Index (SQLite)

## Location

```
.iris/index.sqlite
```

Single database for all runs.

---

## Table: artifacts

Columns:

* artifact_id (PRIMARY KEY)
* run_id
* artifact_type
* storage_kind
* artifact_name
* rel_path
* sha256
* created_at
* producer_id
* producer_kind
* inputs_json (JSON array of artifact_ids)

No ORM required.
Use Python stdlib `sqlite3`.

---

## Index Behavior

* Insert row in transaction per artifact
* SQLite serializes writers
* Queries filter by `run_id` + optional filters
* Rows are immutable facts
* No "current pointer" concept at Layer 0

**Tracking:**

- [x] **Global index** — create/open `.iris/index.sqlite`; single DB for all runs
- [x] **Table artifacts** — create table with all columns; use sqlite3 stdlib
- [x] **Index insert** — insert row in transaction on each put_* after payload durable
- [x] **Index query** — list(run_id, filters...) queries by run_id + optional filters; returns [ArtifactRef]

---

# 7. ArtifactStore API

## 7.1 put_json

```
put_json(artifact_type, payload, metadata, artifact_name=None) -> ArtifactRef
```

* Writes `payload.json`
* Computes sha256
* Inserts index row

---

## 7.2 put_text

```
put_text(artifact_type, payload, metadata, artifact_name=None) -> ArtifactRef
```

Same as JSON but plain text.

---

## 7.3 put_file

```
put_file(artifact_type, source_path, metadata, artifact_name=None, move=False) -> ArtifactRef
```

* Default behavior: copy file
* Optional: move=True
* Always compute sha256 of stored file
* Insert index row

---

## 7.4 get

```
get(artifact_ref) -> payload
```

* Only valid for json/text
* Validates artifact belongs to run

---

## 7.5 open_path

```
open_path(artifact_ref) -> filepath
```

* Only valid for file artifacts
* Returns validated path under run root
* Never returns arbitrary paths

**Tracking:**

- [x] **put_json** — write payload.json, sha256, insert index row; return ArtifactRef
- [x] **put_text** — same for plain text
- [x] **put_file** — copy (default) or move=True; sha256 on stored file; insert index row
- [x] **get** — only json/text; validate ref belongs to run; return payload
- [x] **open_path** — only file artifacts; return validated path under run root

---

# 8. Path Security

All artifact paths:

* Stored as relative paths
* Resolved under run root
* Must pass:

  ```
  resolved_path.is_relative_to(run_root)
  ```

Reject anything that escapes run root.

**Tracking:**

- [x] **Paths relative to run root** — store and resolve only under run root
- [x] **Path traversal check** — resolve then verify is_relative_to(run_root); reject escapes
- [x] **open_path validation** — return only validated path for known artifact_id in index

---

# 9. Invariants

Layer 0 guarantees:

* Manifest writes are atomic
* Artifact payload exists before index row commit
* Index is crash-safe
* Overwrites impossible by construction
* Artifact paths confined to run root
* No half-written manifest
* No JSONL append corruption
* Global search across runs possible

**Tracking:**

- [x] **Manifest writes atomic** — verified (write+fsync+rename+fsync dir)
- [x] **Payload before index commit** — verified in put_* order
- [x] **Index crash-safe** — SQLite transactional
- [x] **Overwrites impossible** — unique artifact_id dirs only
- [x] **Paths confined** — traversal check enforced
- [x] **No half-written manifest** — atomic write only
- [x] **Global search** — queries by run_id (+ filters) across runs

---

# 10. Done Criteria (Layer 0)

Layer 0 is complete when:

- [x] Run directory is created deterministically
- [x] RunManifest is atomic and resumable
- [x] ArtifactStore supports put_json / put_text / put_file
- [x] Global SQLite index is operational
- [x] Path traversal protection enforced
- [x] Hashing always enforced
- [x] Manifest lock used only for manifest writes
- [x] SQLite used for index without run lock
- [x] Artifacts immutable by design

When these conditions hold, higher layers can rely on Layer 0.

---

# 11. CLI Entrypoint (Create Run)

Layer 0 exposes a minimal CLI to create a run from the current workspace (no graph, no agents, no config system).

## Command

* `lily run new` — create a new run under `.iris/runs/<run_id>/` with manifest (status `created`), `artifacts/`, `logs/`, `tmp/`.
* Optional: `--work-order PATH` — read file at path, store as file artifact via ArtifactStore `put_file`, set `work_order_ref` in RunManifest to the returned ArtifactRef (as WorkOrderRef: run_id + artifact_id).

## UX

* Output: “Created run &lt;run_id&gt;”, “Path: &lt;run_root&gt;”. If work order attached: “Attached work order: &lt;artifact_id&gt;”.
* Implemented with Typer (CLI) and Rich (console). Entrypoint: `lily = "lily.cli:app"`.

## Service

* A small service function (e.g. `create_run_with_optional_work_order(workspace_root, work_order_path=None) -> RunInfo`) performs run creation and optional work-order attachment; CLI calls it. RunInfo includes run_id, run_root, work_order_ref.

**Tracking:**

- [x] **CLI command** — `lily run new` with optional `--work-order PATH`; Typer + Rich
- [x] **Run creation** — directory layout + manifest (status=created, kernel_version); optional work order stored as file artifact and `work_order_ref` set in manifest
- [x] **No artifacts outside run root** — work order stored under run’s `artifacts/`
