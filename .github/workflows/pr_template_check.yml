# Fail if the PR body does not follow .github/pull_request_template.md.
# Runs on open, edit, sync, reopen, and when a draft is marked ready.
name: PR body template check

on:
  pull_request:
    types: [opened, edited, synchronize, reopened, ready_for_review]

jobs:
  pr-body-check:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      pull-requests: write
      issues: write
    steps:
      - name: Validate PR body
        uses: actions/github-script@v7
        with:
          script: |
            const pr = context.payload.pull_request;
            // Normalize: strip BOM, collapse line endings to \n
            let body = (pr.body || '')
              .replace(/^\uFEFF/, '')
              .replace(/\r\n/g, '\n')
              .replace(/\r/g, '\n');
            const isDraft = !!pr.draft;

            const COMMENT_MARKER = '<!-- pr-body-template-check -->';

            function fail(msg) {
              core.setFailed(msg);
            }

            async function postOrUpdateComment(commentBody) {
              const fullBody = commentBody + '\n\n' + COMMENT_MARKER;
              const { data: comments } = await github.rest.issues.listComments({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: context.issue.number,
              });
              const botComment = comments.find(c => c.body && c.body.includes(COMMENT_MARKER));
              if (botComment) {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: botComment.id,
                  body: fullBody,
                });
              } else {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: context.issue.number,
                  body: fullBody,
                });
              }
            }

            // Escape regex specials in heading text so we match literally (e.g. "Breaking Change?")
            function escapeHeading(h) {
              return h.replace(/[.*+?^${}()|[\]\\]/g, '\\$&');
            }

            function hasHeading(h) {
              const escaped = escapeHeading(h.replace(/\\(.)/g, '$1'));
              const re = new RegExp(`^#{1,6}\\s+${escaped}\\s*$`, 'im');
              return re.test(body);
            }

            const requiredHeadings = [
              'Summary',
              'Verification',
              'Risk Assessment',
              'Checklist (Ruthless)',
            ];
            const missingHeadings = requiredHeadings.filter(h => !hasHeading(h));
            if (missingHeadings.length) {
              const checklist = missingHeadings.map(h => `- [ ] Add section: **${h}**`).join('\n');
              await postOrUpdateComment(
                '## PR body template check — missing sections\n\n' +
                'Add these required sections to the PR description (see `.github/pull_request_template.md`):\n\n' +
                checklist
              );
              fail(
                'PR body is missing required sections: ' + missingHeadings.join(', ') +
                '\n\nFix: edit the PR description and add the missing headings from .github/pull_request_template.md'
              );
              return;
            }

            function sectionText(heading) {
              const escaped = escapeHeading(heading);
              // Lookahead: next heading (^#{1,6}) OR end of string (?![\s\S]) — not $ which matches every EOL in multiline
              const re = new RegExp(
                `(^#{1,6}\\s+${escaped}\\s*$)([\\s\\S]*?)(?=^#{1,6}\\s+|(?![\\s\\S]))`,
                'im'
              );
              const m = body.match(re);
              return m ? m[2].trim() : '';
            }

            // Match [x] or Unicode ballot box with check (GitHub may normalize)
            const CHECKED_BOX = /\\[x\\]|\u2611|&#x2611;/i;
            function countCheckedInSection(heading) {
              const t = sectionText(heading);
              if (!t) return 0;
              const lines = t.split('\n');
              return lines.filter(line => /^\s*-\s*/.test(line) && CHECKED_BOX.test(line)).length;
            }

            const problems = [];

            // Require at least one checkbox checked in each "answered" section
            const riskChecked = countCheckedInSection('Risk Level');
            const perfChecked = countCheckedInSection('Perf Impact');
            const breakingChecked = countCheckedInSection('Breaking Change?');
            const schemaChecked = countCheckedInSection('Config / Schema Changes');

            if (riskChecked < 1) problems.push('Risk Level: check one of Low / Medium / High.');
            if (perfChecked < 1) problems.push('Perf Impact: check at least one option.');
            if (breakingChecked < 1) problems.push('Breaking Change?: check Yes or No.');
            if (schemaChecked < 1) problems.push('Config / Schema Changes: check None or Yes.');

            // Verification: must mention gates; non-draft must have them checked (under ## Required Gates)
            const verification = sectionText('Verification');
            const requiredGates = sectionText('Required Gates');
            const hasCleanup = /\/cleanup/.test(verification) || /\/cleanup/.test(requiredGates);
            const hasCoverage = /\/coverage/.test(verification) || /\/coverage/.test(requiredGates);
            if (!hasCleanup) problems.push('Verification must mention /cleanup (quality + tests).');
            if (!hasCoverage) problems.push('Verification must mention /coverage (coverage threshold).');
            if (!isDraft) {
              const gatesText = requiredGates || verification;
              const hasCheckedLineWith = (text) => gatesText.split('\n').some(line =>
                /^\s*-\s*/.test(line) && CHECKED_BOX.test(line) && line.includes(text));
              if (!hasCheckedLineWith('/cleanup')) problems.push('Non-draft PRs: check the /cleanup gate in Required Gates.');
              if (!hasCheckedLineWith('/coverage')) problems.push('Non-draft PRs: check the /coverage gate in Required Gates.');
            }

            // Minimal content: Summary not empty, Tests and Failure Modes answered
            const summaryRaw = sectionText('Summary').replace(/<!--[\s\S]*?-->/g, '').replace(/\s/g, '');
            if (summaryRaw.length < 20) {
              problems.push('Summary: add 1–3 sentences (not just placeholders).');
            }

            const testsSection = sectionText('Tests Added / Updated');
            const hasTestBullets = /^\s*-\s+.+/m.test(testsSection);
            const hasNone = /\bnone\b/i.test(testsSection);
            if (!hasTestBullets && !hasNone) {
              problems.push('Tests Added / Updated: list tests or write "None" explicitly.');
            }

            const failureModes = sectionText('Failure Modes Considered');
            const hasFailureBullets = /^\s*-\s+.+/m.test(failureModes);
            const hasNA = /\b(n\/a|n\.a\.|none)\b/i.test(failureModes);
            if (!hasFailureBullets && !hasNA) {
              problems.push('Failure Modes Considered: add at least one bullet or write N/A.');
            }

            if (problems.length) {
              const checklist = problems.map(p => `- [ ] ${p}`).join('\n');
              await postOrUpdateComment(
                '## PR body template check — action needed\n\n' +
                'Update the PR description to fix:\n\n' +
                checklist +
                '\n\nSee `.github/pull_request_template.md` and [CONTRIBUTING.md](https://github.com/' + context.repo.owner + '/' + context.repo.repo + '/blob/HEAD/CONTRIBUTING.md) for how to comply.'
              );
              fail(
                'PR body check failed:\n- ' + problems.join('\n- ') +
                '\n\nUpdate the PR description using .github/pull_request_template.md.'
              );
            }
