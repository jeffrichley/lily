"""Council blueprint implementation (map/reduce specialist workflow)."""

from __future__ import annotations

from collections.abc import Mapping
from enum import StrEnum
from typing import Protocol, cast

from langchain_core.runnables import RunnableLambda, RunnableParallel
from langchain_core.runnables.base import RunnableSerializable
from pydantic import BaseModel, ConfigDict, Field, ValidationError

from lily.blueprints.models import (
    BlueprintError,
    BlueprintErrorCode,
    BlueprintRunEnvelope,
    BlueprintRunStatus,
)

_DEFAULT_ARTIFACTS = ("summary.md", "events.jsonl")


class CouncilSpecialistStatus(StrEnum):
    """Deterministic specialist execution status."""

    OK = "ok"
    ERROR = "error"


class CouncilSynthStrategy(StrEnum):
    """Stable synth strategy selector for council blueprint bindings."""

    DETERMINISTIC = "deterministic"
    LLM = "llm"


class CouncilBindingModel(BaseModel):
    """Bindings schema for council blueprint compilation."""

    model_config = ConfigDict(extra="forbid", frozen=True)

    specialists: tuple[str, ...] = Field(min_length=2)
    synthesizer: str = Field(min_length=1)
    synth_strategy: CouncilSynthStrategy = CouncilSynthStrategy.DETERMINISTIC
    max_findings: int = Field(default=8, ge=1, le=20)


class CouncilInputModel(BaseModel):
    """Input schema for council blueprint execution."""

    model_config = ConfigDict(extra="forbid", frozen=True)

    topic: str = Field(min_length=1)
    context: tuple[str, ...] = ()


class CouncilFinding(BaseModel):
    """Typed finding generated by one specialist."""

    model_config = ConfigDict(extra="forbid", frozen=True)

    title: str = Field(min_length=1)
    recommendation: str = Field(min_length=1)
    confidence: float = Field(ge=0.0, le=1.0)
    source_specialist: str = Field(min_length=1)


class CouncilSpecialistReport(BaseModel):
    """Typed specialist output contract for synthesizer input."""

    model_config = ConfigDict(extra="forbid", frozen=True)

    specialist_id: str = Field(min_length=1)
    status: CouncilSpecialistStatus = CouncilSpecialistStatus.OK
    findings: tuple[CouncilFinding, ...] = ()
    notes: str = ""


class CouncilOutputModel(BaseModel):
    """Typed council synthesis output payload."""

    model_config = ConfigDict(extra="forbid", frozen=True)

    topic: str = Field(min_length=1)
    summary: str = Field(min_length=1)
    ranked_findings: tuple[CouncilFinding, ...] = ()
    participating_specialists: tuple[str, ...] = ()
    failed_specialists: tuple[str, ...] = ()


class CouncilSpecialist(Protocol):
    """Specialist runner contract for one council participant."""

    def run(self, request: CouncilInputModel) -> CouncilSpecialistReport:
        """Execute one specialist pass.

        Args:
            request: Typed council input.
        """


class CouncilSynthesizer(Protocol):
    """Synthesizer runner contract for merged council output."""

    def run(
        self,
        *,
        request: CouncilInputModel,
        reports: tuple[CouncilSpecialistReport, ...],
        max_findings: int,
    ) -> CouncilOutputModel:
        """Synthesize specialist reports into one typed output payload.

        Args:
            request: Typed council input.
            reports: Specialist report set.
            max_findings: Maximum finding count.
        """


class CouncilSynthesisError(RuntimeError):
    """Deterministic synthesis failure raised by strategy wrappers."""

    def __init__(self, *, code: str, message: str) -> None:
        """Store stable synthesis failure payload.

        Args:
            code: Stable machine-readable synthesis code.
            message: Human-readable synthesis failure message.
        """
        super().__init__(message)
        self.code = code


class _DeterministicSynthesizer:
    """Default deterministic council synthesizer."""

    def run(
        self,
        *,
        request: CouncilInputModel,
        reports: tuple[CouncilSpecialistReport, ...],
        max_findings: int,
    ) -> CouncilOutputModel:
        """Merge specialist findings with deterministic sort/ranking.

        Args:
            request: Typed council input.
            reports: Specialist report set.
            max_findings: Maximum finding count.

        Returns:
            Deterministic merged output payload.
        """
        findings = [
            finding
            for report in reports
            if report.status == CouncilSpecialistStatus.OK
            for finding in report.findings
        ]
        ranked = sorted(
            findings,
            key=lambda item: (-item.confidence, item.source_specialist, item.title),
        )[:max_findings]
        failed = tuple(
            report.specialist_id
            for report in reports
            if report.status == CouncilSpecialistStatus.ERROR
        )
        summary = (
            f"Council reviewed '{request.topic}' with {len(reports)} specialists; "
            f"{len(ranked)} ranked findings generated."
        )
        return CouncilOutputModel(
            topic=request.topic,
            summary=summary,
            ranked_findings=tuple(ranked),
            participating_specialists=tuple(report.specialist_id for report in reports),
            failed_specialists=failed,
        )


class LLMSynthesizer:
    """Optional LLM synthesis strategy with deterministic fallback behavior."""

    def __init__(
        self,
        *,
        primary: CouncilSynthesizer,
        fallback: CouncilSynthesizer,
    ) -> None:
        """Store strategy chain for LLM synthesis.

        Args:
            primary: LLM-backed synthesis strategy.
            fallback: Deterministic fallback synthesis strategy.
        """
        self._primary = primary
        self._fallback = fallback

    def run(
        self,
        *,
        request: CouncilInputModel,
        reports: tuple[CouncilSpecialistReport, ...],
        max_findings: int,
    ) -> CouncilOutputModel:
        """Execute primary synth and fall back deterministically on failure.

        Args:
            request: Typed council input.
            reports: Specialist report set.
            max_findings: Maximum finding count.

        Returns:
            Typed council output payload.

        Raises:
            CouncilSynthesisError: If primary and fallback both fail.
        """
        try:
            primary_output = self._primary.run(
                request=request,
                reports=reports,
                max_findings=max_findings,
            )
            return CouncilOutputModel.model_validate(primary_output)
        except Exception as primary_exc:
            try:
                fallback_output = CouncilOutputModel.model_validate(
                    self._fallback.run(
                        request=request,
                        reports=reports,
                        max_findings=max_findings,
                    )
                )
            except Exception as fallback_exc:
                raise CouncilSynthesisError(
                    code="llm_synth_fallback_failed",
                    message=(
                        "Error: council synthesis failed in both llm and "
                        "deterministic fallback paths."
                    ),
                ) from fallback_exc
            return fallback_output.model_copy(
                update={
                    "summary": (
                        f"{fallback_output.summary} "
                        f"[fallback: llm_synth_failed ({primary_exc})]"
                    )
                }
            )


class CouncilCompiledRunnable:
    """Compiled council runnable using LCEL parallel map + reduce composition."""

    def __init__(
        self,
        *,
        blueprint_id: str,
        specialists: Mapping[str, CouncilSpecialist],
        synthesizer: CouncilSynthesizer,
        max_findings: int,
    ) -> None:
        """Create compiled council runnable.

        Args:
            blueprint_id: Stable source blueprint id.
            specialists: Specialist runners keyed by specialist id.
            synthesizer: Synthesis runner.
            max_findings: Maximum finding count in output payload.
        """
        self._blueprint_id = blueprint_id
        self._specialists = dict(specialists)
        self._synthesizer = synthesizer
        self._max_findings = max_findings
        self._chain = self._build_chain()

    def invoke(self, raw_input: Mapping[str, object]) -> BlueprintRunEnvelope:
        """Execute compiled council workflow for one request.

        Args:
            raw_input: Raw user input payload.

        Returns:
            Run Contract R0 envelope.

        Raises:
            BlueprintError: If execution fails.
        """
        try:
            parsed = CouncilInputModel.model_validate(dict(raw_input))
        except ValidationError as exc:
            raise BlueprintError(
                BlueprintErrorCode.EXECUTION_FAILED,
                "Error: council execution input is invalid.",
                data={
                    "blueprint": self._blueprint_id,
                    "validation_errors": exc.errors(),
                },
            ) from exc
        try:
            output = self._chain.invoke(parsed)
        except BlueprintError:
            raise
        except Exception as exc:  # pragma: no cover - defensive
            raise BlueprintError(
                BlueprintErrorCode.EXECUTION_FAILED,
                "Error: council execution failed.",
                data={"blueprint": self._blueprint_id, "reason": str(exc)},
            ) from exc
        return BlueprintRunEnvelope(
            status=BlueprintRunStatus.OK,
            artifacts=_DEFAULT_ARTIFACTS,
            approvals_requested=(),
            references=tuple(self._specialists.keys()),
            payload=output.model_dump(mode="json"),
        )

    def _build_chain(
        self,
    ) -> RunnableSerializable[CouncilInputModel, CouncilOutputModel]:
        """Build LCEL map/reduce council execution chain.

        Returns:
            Runnable chain producing `CouncilOutputModel`.
        """
        parallel = RunnableParallel(
            {
                specialist_id: self._build_specialist_step(specialist_id)
                for specialist_id in self._specialists
            }
        )
        collect = cast(
            RunnableSerializable[CouncilInputModel, dict[str, object]],
            RunnableLambda(
                lambda request: {
                    "request": request,
                    "reports_map": parallel.invoke(request),
                }
            ),
        )
        reduce_step = cast(
            RunnableSerializable[dict[str, object], CouncilOutputModel],
            RunnableLambda(
                lambda payload: self._reduce_reports(
                    request=payload["request"],
                    reports=tuple(payload["reports_map"].values()),
                )
            ),
        )
        return collect | reduce_step

    def _reduce_reports(
        self,
        *,
        request: CouncilInputModel,
        reports: tuple[CouncilSpecialistReport, ...],
    ) -> CouncilOutputModel:
        """Run synthesis step with deterministic LLM-failure error mapping.

        Args:
            request: Typed council input payload.
            reports: Specialist report set.

        Returns:
            Typed council output payload.

        Raises:
            BlueprintError: If synthesis fails after fallback strategy.
        """
        try:
            return self._synthesizer.run(
                request=request,
                reports=reports,
                max_findings=self._max_findings,
            )
        except CouncilSynthesisError as exc:
            raise BlueprintError(
                BlueprintErrorCode.EXECUTION_FAILED,
                "Error: council synthesis failed.",
                data={
                    "blueprint": self._blueprint_id,
                    "synth_error_code": exc.code,
                },
            ) from exc

    def _build_specialist_step(
        self, specialist_id: str
    ) -> RunnableLambda[CouncilInputModel, CouncilSpecialistReport]:
        """Build one LCEL specialist runnable step.

        Args:
            specialist_id: Specialist identifier to bind.

        Returns:
            Runnable step for mapped specialist execution.
        """
        return RunnableLambda(
            lambda request: self._run_specialist(specialist_id, request)
        )

    def _run_specialist(
        self,
        specialist_id: str,
        request: CouncilInputModel,
    ) -> CouncilSpecialistReport:
        """Run one specialist with deterministic failure containment.

        Args:
            specialist_id: Specialist identifier.
            request: Typed council input payload.

        Returns:
            Specialist report (error status on containment path).
        """
        specialist = self._specialists[specialist_id]
        try:
            report = specialist.run(request)
        except Exception as exc:
            return CouncilSpecialistReport(
                specialist_id=specialist_id,
                status=CouncilSpecialistStatus.ERROR,
                findings=(),
                notes=f"specialist execution failed: {exc}",
            )
        if report.specialist_id != specialist_id:
            return report.model_copy(update={"specialist_id": specialist_id})
        return report


class CouncilBlueprint:
    """`council.v1` blueprint implementation."""

    id = "council.v1"
    version = "1.0.0"
    summary = "Parallel specialist council with deterministic synthesis."
    bindings_schema = CouncilBindingModel
    input_schema = CouncilInputModel
    output_schema = CouncilOutputModel

    def __init__(
        self,
        *,
        specialists: Mapping[str, CouncilSpecialist],
        synthesizers: Mapping[str, CouncilSynthesizer] | None = None,
        llm_synthesizers: Mapping[str, CouncilSynthesizer] | None = None,
    ) -> None:
        """Create council blueprint dependencies.

        Args:
            specialists: Specialist runners keyed by id.
            synthesizers: Optional synthesizer runners keyed by id.
            llm_synthesizers: Optional llm synth runners keyed by id.
        """
        self._specialists = dict(specialists)
        self._synthesizers = (
            dict(synthesizers)
            if synthesizers is not None
            else {"default.v1": _DeterministicSynthesizer()}
        )
        self._llm_synthesizers = (
            dict(llm_synthesizers) if llm_synthesizers is not None else {}
        )

    def compile(self, bindings: BaseModel) -> CouncilCompiledRunnable:
        """Compile council blueprint into executable runnable.

        Args:
            bindings: Validated council bindings payload.

        Returns:
            Compiled runnable.

        Raises:
            BlueprintError: If dependencies referenced by bindings cannot resolve.
        """
        parsed = CouncilBindingModel.model_validate(bindings)
        unresolved = tuple(
            specialist_id
            for specialist_id in parsed.specialists
            if specialist_id not in self._specialists
        )
        if unresolved:
            raise BlueprintError(
                BlueprintErrorCode.COMPILE_FAILED,
                "Error: council compile failed due to unresolved specialists.",
                data={"blueprint": self.id, "unresolved_specialists": unresolved},
            )
        synth_strategy = parsed.synth_strategy
        if synth_strategy == CouncilSynthStrategy.DETERMINISTIC:
            synthesizer = self._synthesizers.get(parsed.synthesizer)
            if synthesizer is None:
                raise BlueprintError(
                    BlueprintErrorCode.COMPILE_FAILED,
                    "Error: council compile failed due to unresolved synthesizer.",
                    data={
                        "blueprint": self.id,
                        "unresolved_synthesizer": parsed.synthesizer,
                    },
                )
        else:
            primary = self._llm_synthesizers.get(parsed.synthesizer)
            if primary is None:
                raise BlueprintError(
                    BlueprintErrorCode.COMPILE_FAILED,
                    "Error: council compile failed due to unresolved llm synthesizer.",
                    data={
                        "blueprint": self.id,
                        "unresolved_llm_synthesizer": parsed.synthesizer,
                    },
                )
            fallback = self._synthesizers.get("default.v1")
            if fallback is None:
                raise BlueprintError(
                    BlueprintErrorCode.COMPILE_FAILED,
                    (
                        "Error: council compile failed due to missing deterministic "
                        "fallback synthesizer."
                    ),
                    data={"blueprint": self.id},
                )
            synthesizer = LLMSynthesizer(primary=primary, fallback=fallback)
        resolved = {
            specialist_id: self._specialists[specialist_id]
            for specialist_id in parsed.specialists
        }
        return CouncilCompiledRunnable(
            blueprint_id=self.id,
            specialists=resolved,
            synthesizer=synthesizer,
            max_findings=parsed.max_findings,
        )
